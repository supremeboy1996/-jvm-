## 2.3 HotSpot虚拟机对象探秘

### 2.3.1 对象的创建

<img src="https://images2015.cnblogs.com/blog/592743/201603/592743-20160319235423381-1926278401.png" alt="img" style="zoom: 80%;" />

<center>对象的创建过程</center>

​		分配内存的方式有两种，指针碰撞和空闲列表。如果Java堆中的内存是规整的，采用指针碰撞，否则采用空闲列表。Java堆内存是否规则取决于采用的垃圾收集器是否带有空闲压缩整理能力。

​		并发情况下修改指针指向的位置不是线程安全的，比如正在给对象A分配内存，指针还没来得及修改，对象B又使用了原来的指针来分配内存。解决方案：

* 对分配内存空间的动作进行同步处理——采用CAS配上失败重试
* 采用本地线程分配缓冲TLAB。线程在堆中预先分配出本地线程分配缓冲，本地缓冲用完了，分配新的缓存区时采用同步锁定的方法。启用参数-XX:+/-UseTLAB

### 2.3.2 对象的内存布局

​		对象在队中划分为三个部分：对象头、实例数据和对其填充。

* 对象头包括用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向事件戳等。另一部分是类型指针，即对象指向它类型元数据的指针，JVM通过此来判断对象是哪个类型的实例。
* 实例数据部分是队先后真正存储的有效信息，各种字段，包括继承的字段。存储顺序受到JVM分配策略参数和字段在源码中的定义顺序的影响。JVM默认的分配顺序为long/double、ints、shorts/chars、bytes/boolean、opps（大小相同的在一起，大前小后，最后是对象）。
* 对齐填充。仅仅起占位作用，补全实例数据部分，使其成为8字节的倍数。

### 2.2.3 对象的访问定位

建立对象就是为了使用对象，我们的Java程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式有虚拟机实现而定，目前主流的访问方式有使用句柄和直接指针两种：

1. 句柄： 如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。
   ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190417214133394.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvZGVtYWxl,size_16,color_FFFFFF,t_70)
   通过句柄访问对象
2. 直接指针： 如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象的地址。
   ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190417214138689.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvZGVtYWxl,size_16,color_FFFFFF,t_70)
   通过直接指针访问对象
   这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。